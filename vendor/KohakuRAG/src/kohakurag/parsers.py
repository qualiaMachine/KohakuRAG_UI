"""Convert text/Markdown/JSON into structured DocumentPayloads.

These parsers provide the entry point for ingesting different document formats
into the hierarchical structure KohakuRAG expects.
"""

import re
from dataclasses import asdict
from typing import Any

from .text_utils import split_paragraphs, split_sentences
from .types import (
    DocumentPayload,
    ParagraphPayload,
    SectionPayload,
    SentencePayload,
)

HEADING_RE = re.compile(r"^(#{1,6})\s+(.*)$")


def text_to_payload(
    *,
    document_id: str,
    title: str,
    text: str,
    metadata: dict[str, Any],
) -> DocumentPayload:
    """Convert plain text into hierarchical payload using heuristic segmentation."""
    paragraphs = [
        ParagraphPayload(
            text=paragraph,
            sentences=[
                SentencePayload(text=sentence)
                for sentence in split_sentences(paragraph)
            ],
        )
        for paragraph in split_paragraphs(text)
    ]
    sections = [
        SectionPayload(
            title=title,
            paragraphs=paragraphs,
            metadata={"autogenerated": True},
        )
    ]
    return DocumentPayload(
        document_id=document_id,
        title=title,
        text=text,
        metadata=metadata,
        sections=sections,
    )


def markdown_to_payload(
    *,
    document_id: str,
    title: str,
    markdown_text: str,
    metadata: dict[str, Any],
) -> DocumentPayload:
    """Parse Markdown using # headings as section boundaries.

    Strategy:
    - Lines starting with # create new sections
    - Blank lines separate paragraphs
    - Falls back to plain text parser if no headings found
    """
    sections: list[SectionPayload] = []
    current_paragraph_lines: list[str] = []
    current_title = title
    current_metadata: dict[str, Any] = {}
    section_paragraphs: list[ParagraphPayload] = []

    def flush_paragraph() -> None:
        """Save accumulated lines as a paragraph."""
        if not current_paragraph_lines:
            return

        paragraph_text = "\n".join(current_paragraph_lines).strip()
        current_paragraph_lines.clear()

        sentences = [
            SentencePayload(text=sentence)
            for sentence in split_sentences(paragraph_text)
        ]
        section_paragraphs.append(
            ParagraphPayload(
                text=paragraph_text,
                sentences=sentences,
            )
        )

    def flush_section() -> None:
        """Save accumulated paragraphs as a section."""
        if section_paragraphs:
            sections.append(
                SectionPayload(
                    title=current_title,
                    paragraphs=list(section_paragraphs),
                    metadata=dict(current_metadata),
                )
            )
            section_paragraphs.clear()

    # Parse line by line
    for line in markdown_text.splitlines():
        heading_match = HEADING_RE.match(line)

        if heading_match:
            # Start new section at each heading
            flush_paragraph()
            flush_section()
            current_title = heading_match.group(2).strip()
            current_metadata = {"level": len(heading_match.group(1))}
            continue

        if not line.strip():
            # Blank line ends paragraph
            flush_paragraph()
            continue

        # Accumulate content line
        current_paragraph_lines.append(line)

    # Flush final paragraph/section
    flush_paragraph()
    flush_section()

    # Fallback if no headings found
    if not sections:
        sections = (
            text_to_payload(
                document_id=document_id,
                title=title,
                text=markdown_text,
                metadata=metadata,
            ).sections
            or []
        )

    return DocumentPayload(
        document_id=document_id,
        title=title,
        text=markdown_text,
        metadata=metadata,
        sections=sections,
    )


def payload_to_dict(payload: DocumentPayload) -> dict:
    """Serialize DocumentPayload to JSON-compatible dict."""
    return asdict(payload)


def dict_to_payload(data: dict[str, Any]) -> DocumentPayload:
    """Deserialize dict (from JSON) back to DocumentPayload."""
    sections_data = data.get("sections") or []
    sections: list[SectionPayload] = []

    # Rebuild nested structure
    for section in sections_data:
        paragraphs: list[ParagraphPayload] = []

        for paragraph in section.get("paragraphs", []):
            sentences = [
                SentencePayload(
                    text=sentence.get("text", ""),
                    metadata=sentence.get("metadata", {}),
                )
                for sentence in paragraph.get("sentences", []) or []
            ]

            paragraphs.append(
                ParagraphPayload(
                    text=paragraph.get("text", ""),
                    sentences=sentences or None,
                    metadata=paragraph.get("metadata", {}),
                )
            )

        sections.append(
            SectionPayload(
                title=section.get("title", ""),
                paragraphs=paragraphs,
                metadata=section.get("metadata", {}),
            )
        )

    return DocumentPayload(
        document_id=data["document_id"],
        title=data.get("title", data["document_id"]),
        text=data.get("text", ""),
        metadata=data.get("metadata", {}),
        sections=sections or None,
    )
